# 파이썬 함수의 시간 복잡도
## 리스트
배열 기반의 구조로, 인덱스를 활용한 접근 및 맨 끝부분에서 추가및 제거가 빠릅니다. 하지만 원소의 중간에서 삽입/삭제 하거나 왼소의 맨 처음에 삽입하는 경우에는 상당히 비효율적입니다. 아래 list는 임의 변수이름 입니다.  아래 표에서 lst는 리스트 타입의 변수 입니다.


| 메서드   | 동작                                    | 시간복잡도|
| ---------- | ---------------------------------------------- |------------------------------ |
| lst.append(item)    | item을 lst의 맨 끝에 추가                                    | O(1) |
| lst.insert(idx,item)    | item을 lst의 idx 위치에 삽입</br>(그 이후 원소들은 한칸씩 밀림) | O(N),N은 lst의 길이          |  
| lst.pop()    | lst의 마지막 원소 제거 후, 해당 원소 반환                                    | O(1) |
| lst.pop(0)    | lst의 첫 번째 원소 제거 후 해당 원소 반환</br>(모든 원소가 앞으로 한 칸씩 이동)| O(N),N은 lst의 길이 |
| lst.remove(item)    | lst에서 item과 일치하는 첫번째 원소 찾아서 제거                                    | O(N),N은 lst의 길이 |
| lst.extend(s)    | lst모든 원소들을 현재 리스트의 끝에 추가                                    | O(N),N은 lst의 길이 |
| lst[K]    | lst의 k번째 인덱스에 있는 요소를 반환합니다.                                    | O(1) |
| lst1 + lst2    | lst1와 lst2의 원소들을 하나의 리스트를 결합하고, 해당 리스트를 반환                                    | O(N+M), N은 lst1의 길이이고, M은 lst2의 길이 |
| list(set)   | set을 list로 변환 후 반환                                    | O(N), N은 set의 길이 |
| item in lst    | lst에 K가 있는지 확인 한후, True 혹은 False 반환                                    | O(N) N은 lst의 길이 |

## 덱
덱은 내부적으로 이중 연결 리스트로 구현되어 있습니다. 양쪽 끝에서 추가 및 제거 작업이 매우 빠릅니다. 삽입/삭제 연산 모두 시간복잡도 O(1) 입니다. 하지만 리스트와 마찬가지로 중간에서 삽입/삭제는 느립니다. 인덱스를 활용해서 접근할 수는 있지만, 인덱스 접근 연산은 덱의 원소개수가 N개일때, 시간복잡도가 O(N)이므로 리스트에 비해 느립니다.  아래 표에서 deq는 덱 타입의 변수 입니다.

| 메서드   | 동작                                    | 시간복잡도|
| ---------- | ---------------------------------------------- |------------------------------ |
| deq.append(item) | item을 deq의 오른쪽 끝에 추가 |O(1) |
| deq.appendleft(item) | item을 deq의 왼쪽 끝에 추가 |O(1) |
| deq.popleft() | deq의 오른쪽 끝에 있는 원소를 제거하고, 그 원소를 반환 |O(1) |
| deq[K] | deq의 K번째 위치에 있는 원소를 반환 |O(N), N은 deq의 길이 |


<작업중>
