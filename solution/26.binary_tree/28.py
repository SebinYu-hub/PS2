"""
[Input]
1. n: int
   - 참가자 수 (2의 지수)
   - 제약: 2 ≤ n ≤ 2^20
   - 제약: n은 항상 2의 지수

2. a: int
   - 첫 번째 선수의 번호
   - 제약: 1 ≤ a ≤ n

3. b: int
   - 두 번째 선수의 번호
   - 제약: 1 ≤ b ≤ n
   - 제약: a ≠ b

[Output]
- result: int
  - 두 선수가 만나는 라운드 번호
  - 제약: 1 ≤ result ≤ log2(n)
  - 제약: 두 선수는 반드시 만남
"""
"""
[문제 특징] : [알고리즘 선택 이유]
1. 토너먼트 구조 : 이진 트리 레벨 계산
2. 번호 매핑 필요 : 부모 노드 인덱스 계산
3. 라운드 진행 필요 : 번호 갱신 규칙 활용
4. 만나는 시점 확인 필요 : 같은 부모를 가질 때까지 반복
5. 효율적 계산 필요 : O(log N) 시간 복잡도
"""
"""
[자료구조]
1. round_count: int
   - 목적: 라운드 수 카운트
   - 특징: 0부터 증가
   - 연산: 증가 연산

[알고리즘: Tournament Round]
procedure solution(n, a, b):
    1. Initialize:
       - 라운드 카운터 초기화
    
    2. Process rounds:
       - 두 선수의 번호가 같아질 때까지:
         a) 다음 라운드 번호 계산 ((N+1)//2)
         b) 라운드 카운트 증가
    
    3. Return result:
       - 최종 라운드 수 반환
"""

def solution(n, a, b):
    """
    토너먼트 대진표에서 두 참가자가 만나는 라운드 계산
    
    Args:
        n: 참가자 수 (2의 지수)
        a, b: 두 참가자의 번호
        
    Returns:
        두 참가자가 만나는 라운드 번호
    """
    round_count = 0
    
    # 두 참가자의 번호가 같아질 때까지 반복
    # (같아진다는 것은 같은 대진에서 만난다는 의미)
    while a != b:
        # 다음 라운드의 번호 계산
        # (현재 번호 + 1) // 2가 다음 라운드에서의 번호
        a = (a + 1) // 2
        b = (b + 1) // 2
        round_count += 1
        
    return round_count

# 예시 실행
# print(solution(8, 4, 7))  # 3
# print(solution(8, 1, 2))  # 1
