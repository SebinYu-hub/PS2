"""
    트리를 인접 리스트로 구현하는 예시입니다.
    
    인접 리스트(adjacency list)는 그래프의 각 정점에 인접한(즉, 직접 연결된) 정점의 리스트를 저장하여 그래프를 표현하는 방식입니다. 인접 리스트의 기본 개념은 각 노드 i의 모든 이웃을 리스트로 관리하는 것입니다.
    
    트리도 사이클이 없는 그래프의 한 형태이므로, 인접 리스트로 구현이 가능합니다. 트리는 일반적으로 부모 노드와 자식 노드 간의 관계를 가지며, 이를 인접 리스트로 표현할 때는 각 노드를 키로하고, 그 노드의 자식들을 값으로 가지는 리스트로 표현합니다.
    
    도식화:
        예를 들어, 다음과 같은 트리를 생각해 봅시다.
            1
           / \
          2   3
         / \
        4   5
        
        이 트리를 인접 리스트로 표현하면 다음과 같습니다.
        {
            1: [2, 3],
            2: [4, 5],
            3: [],
            4: [],
            5: []
        }
        
        여기서 1이라는 키에는 [2, 3]이라는 값이 연결되어 있습니다. 이는 노드 1이 노드 2와 3과 연결되어 있음을 나타냅니다. 비슷하게, 노드 2는 노드 4와 5와 연결되어 있습니다.
        
    시간 복잡도:
        - 노드를 찾는 작업: O(1)
        - 노드의 인접 리스트를 순회하는 작업: O(deg(v)) [deg(v)는 노드 v의 차수(degree)]
        
    즉, 트리를 순회하는 총 시간 복잡도는 O(N)이며, N은 트리의 노드 수입니다. 모든 노드를 정확히 한 번씩 방문하기 때문입니다.
"""

# 트리를 인접 리스트로 표현
tree = {
    1: [2, 3],
    2: [4, 5],
    3: [],
    4: [],
    5: []
}

def print_tree(t, root):
    """
    주어진 루트에서 시작하여 트리를 출력합니다.
    """
    print(root, end=' ')
    for child in t[root]:
        print_tree(t, child)

print("Tree traversal:")
print_tree(tree, 1)  # 1 2 4 5 3

"""
위 함수에서 트리를 순회하는 방식은 깊이 우선 탐색(DFS)과 유사합니다. 
루트 노드에서 시작해서 자식 노드로 재귀적으로 이동하면서 값을 출력합니다.
"""
